<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="iOS,Objective-C,GCD,多线程," />





  <link rel="alternate" href="/atom.xml" title="Wossoneri`s Blog" type="application/atom+xml" />






<meta name="description" content="看到一篇很好的文章，本来想翻译的，但发现已经有人翻译了，遂简单整理了一下，方便阅读学习">
<meta name="keywords" content="iOS,Objective-C,GCD,多线程">
<meta property="og:type" content="article">
<meta property="og:title" content="[Objective-C]深入理解GCD">
<meta property="og:url" content="http://wossoneri.github.io/2016/05/30/[Objective-C]GCD-in-depth/index.html">
<meta property="og:site_name" content="Wossoneri`s Blog">
<meta property="og:description" content="看到一篇很好的文章，本来想翻译的，但发现已经有人翻译了，遂简单整理了一下，方便阅读学习">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://cdn3.raywenderlich.com/wp-content/uploads/2014/01/Concurrency_vs_Parallelism.png">
<meta property="og:image" content="https://cdn2.raywenderlich.com/wp-content/uploads/2014/01/Serial-Queue-480x272.png">
<meta property="og:image" content="https://cdn1.raywenderlich.com/wp-content/uploads/2014/01/Concurrent-Queue-480x272.png">
<meta property="og:image" content="https://cdn1.raywenderlich.com/wp-content/uploads/2014/01/Workflow1.png">
<meta property="og:image" content="http://www.raywenderlich.com/wp-content/uploads/2014/01/NSLog-Race-Condition.png">
<meta property="og:image" content="https://cdn1.raywenderlich.com/wp-content/uploads/2014/01/Highlander_dispatch_once-480x274.png">
<meta property="og:image" content="http://www.raywenderlich.com/wp-content/uploads/2014/01/Dispatch-Barrier.png">
<meta property="og:image" content="http://www.raywenderlich.com/wp-content/uploads/2014/01/dispatch_sync_in_action.gif">
<meta property="og:image" content="http://www.raywenderlich.com/wp-content/uploads/2014/01/dispatch_async_in_action.gif">
<meta property="og:image" content="http://www.raywenderlich.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-17-at-5.49.51-PM.png">
<meta property="og:image" content="https://cdn5.raywenderlich.com/wp-content/uploads/2014/01/Dispatch_Sources_Xcode_Breakpoint_Console-650x500.png">
<meta property="og:image" content="https://cdn1.raywenderlich.com/wp-content/uploads/2014/01/Dispatch_Sources_Debugger_Updating_UI-308x500.png">
<meta property="og:updated_time" content="2016-06-08T10:03:04.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="[Objective-C]深入理解GCD">
<meta name="twitter:description" content="看到一篇很好的文章，本来想翻译的，但发现已经有人翻译了，遂简单整理了一下，方便阅读学习">
<meta name="twitter:image" content="https://cdn3.raywenderlich.com/wp-content/uploads/2014/01/Concurrency_vs_Parallelism.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '6234852363740382000',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://wossoneri.github.io/2016/05/30/[Objective-C]GCD-in-depth/"/>





  <title>[Objective-C]深入理解GCD | Wossoneri`s Blog</title>
  




<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-70716047-2', 'auto');
  ga('send', 'pageview');
</script>


  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?0af9c6850b24b42a4713ad1c9c691675";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>
    <a href="https://github.com/wossoneri"><img style="position: absolute; top: 0; left: 0; border: 0;" src="https://camo.githubusercontent.com/121cd7cbdc3e4855075ea8b558508b91ac463ac2/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f6c6566745f677265656e5f3030373230302e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_left_green_007200.png"></a>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Wossoneri`s Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">业 精于勤而荒于嬉，行 成于思而毁于随</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://wossoneri.github.io/2016/05/30/[Objective-C]GCD-in-depth/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Wossoneri">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="https://avatars2.githubusercontent.com/u/11764431?v=3&s=460">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Wossoneri`s Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">[Objective-C]深入理解GCD</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-30T23:46:42+08:00">
                2016-05-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Syntax/" itemprop="url" rel="index">
                    <span itemprop="name">Syntax</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2016/05/30/[Objective-C]GCD-in-depth/" class="leancloud_visitors" data-flag-title="[Objective-C]深入理解GCD">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          
	
  		  <span class="post-letters-count">
            &nbsp; | &nbsp;
            <span class="post-meta-item-icon">
                 <i class="fa fa-clock-o" ></i>
            </span>
		        <span class="post-meta-item-text">总记</span>
            <span class="post-count">14,335 字</span>
		        <span class="post-meta-item-text">读完需要</span>
    		    <span class="post-count">52 分</span>
  		  </span>
           
         

          

          

          
              <div class="post-description">
                  看到一篇很好的文章，本来想翻译的，但发现已经有人翻译了，遂简单整理了一下，方便阅读学习
              </div>
          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="什么是GCD"><a href="#什么是GCD" class="headerlink" title="什么是GCD"></a>什么是GCD</h3><p><code>GCD</code>(Grand Central Dispatch)是<code>libdispatch</code>的市场名称，而<code>libdispatch</code>作为Apple的一个库，为并发代码在多核硬件（跑 iOS 或 OS X ）上执行提供有力支持。它具有以下优点：</p>
<ol>
<li>GCD能通过推迟昂贵计算任务并在后台运行它们来改善你的应用的响应性能。</li>
<li>GCD提供一个易于使用的并发模型而不仅仅只是锁和线程，以帮助我们避开并发陷阱。</li>
<li>GCD具有在常见模式（例如单例）上用更高性能的原语优化你的代码的潜在能力。<br>本教程假设你对 <code>Block</code> 和 <code>GCD</code> 有基础了解。如果你对 <code>GCD</code> 完全陌生，先看看 <a href="http://www.raywenderlich.com/4295/multithreading-and-grand-central-dispatch-on-ios-for-beginners-tutorial" target="_blank" rel="external">iOS 上的多线程和 GCD 入门教程</a> 或者 <a href="http://www.wossoneri.com/2016/05/30/[iOS]Multithreading-and-GCD/" target="_blank" rel="external">iOS多线程和GCD</a>  学习其要领。</li>
</ol>
<h3 id="GCD术语"><a href="#GCD术语" class="headerlink" title="GCD术语"></a>GCD术语</h3><p>要理解 <code>GCD</code> ，你要先熟悉与线程和并发相关的几个概念。这两者都可能模糊和微妙，所以在开始 <code>GCD</code> 之前先简要地回顾一下它们。</p>
<h4 id="Serial串行-vs-Concurrent并发"><a href="#Serial串行-vs-Concurrent并发" class="headerlink" title="Serial串行 vs. Concurrent并发"></a>Serial串行 vs. Concurrent并发</h4><p>这些术语描述当任务相对于其它任务被执行，任务串行执行就是每次只有一个任务被执行，任务并发执行就是在同一时间可以有多个任务被执行。</p>
<p>虽然这些术语被广泛使用，本教程中你可以将任务设定为一个 <code>Objective-C</code> 的 <code>Block</code> 。不明白什么是 <code>Block</code> ？<a href="http://www.raywenderlich.com/9328/creating-a-diner-app-using-blocks-part-1" target="_blank" rel="external">看看 iOS 5 教程中的如何使用 Block</a> 。实际上，你也可以在 <code>GCD</code> 上使用函数指针，但在大多数场景中，这实际上更难于使用。Block 就是更加容易些！</p>
<h4 id="Synchronous同步-vs-Asynchronous异步"><a href="#Synchronous同步-vs-Asynchronous异步" class="headerlink" title="Synchronous同步 vs. Asynchronous异步"></a>Synchronous同步 vs. Asynchronous异步</h4><p>在 <code>GCD</code> 中，这些术语描述当一个函数相对于另一个任务完成，此任务是该函数要求 <code>GCD</code> 执行的。一个同步函数只在完成了它预定的任务后才返回。</p>
<p>一个异步函数，刚好相反，会立即返回，预定的任务会完成但不会等它完成。因此，一个异步函数不会阻塞当前线程去执行下一个函数。</p>
<h4 id="Critical-Section-临界区"><a href="#Critical-Section-临界区" class="headerlink" title="Critical Section 临界区"></a>Critical Section 临界区</h4><p>就是一段代码不能被并发执行，也就是，两个线程不能同时执行这段代码。这很常见，因为代码去操作一个共享资源，例如一个变量若能被并发进程访问，那么它很可能会变质。</p>
<h4 id="Race-Condition-竞态条件"><a href="#Race-Condition-竞态条件" class="headerlink" title="Race Condition 竞态条件"></a>Race Condition 竞态条件</h4><p>这种状况是指基于特定序列或时机的事件的软件系统以不受控制的方式运行的行为，例如程序的并发任务执行的确切顺序。竞态条件可导致无法预测的行为，而不能通过代码检查立即发现。</p>
<h4 id="Deadlock-死锁"><a href="#Deadlock-死锁" class="headerlink" title="Deadlock 死锁"></a>Deadlock 死锁</h4><p>两个（有时更多）东西——在大多数情况下，是线程——所谓的死锁是指它们都卡住了，并等待对方完成或执行其它操作。第一个不能完成是因为它在等待第二个的完成。但第二个也不能完成，因为它在等待第一个的完成。</p>
<h4 id="Thread-Safe-线程安全"><a href="#Thread-Safe-线程安全" class="headerlink" title="Thread Safe 线程安全"></a>Thread Safe 线程安全</h4><p>线程安全的代码能在多线程或并发任务中被安全的调用，而不会导致任何问题（数据损坏，崩溃，等）。线程不安全的代码在某个时刻只能在一个上下文中运行。一个线程安全代码的例子是 <code>NSDictionary</code> 。你可以在同一时间在多个线程中使用它而不会有问题。另一方面，<code>NSMutableDictionary</code> 就不是线程安全的，应该保证一次只能有一个线程访问它。</p>
<h4 id="Context-Switch-上下文切换"><a href="#Context-Switch-上下文切换" class="headerlink" title="Context Switch 上下文切换"></a>Context Switch 上下文切换</h4><p>一个上下文切换指当你在单个进程里切换执行不同的线程时存储与恢复执行状态的过程。这个过程在编写多任务应用时很普遍，但会带来一些额外的开销。</p>
<h4 id="Concurrency并发-vs-Parallelism并行"><a href="#Concurrency并发-vs-Parallelism并行" class="headerlink" title="Concurrency并发 vs Parallelism并行"></a>Concurrency并发 vs Parallelism并行</h4><p>并发和并行通常被一起提到，所以值得花些时间解释它们之间的区别。<br>并发代码的不同部分可以“同步”执行。然而，该怎样发生或是否发生都取决于系统。多核设备通过并行来同时执行多个线程；然而，为了使单核设备也能实现这一点，它们必须先运行一个线程，执行一个上下文切换，然后运行另一个线程或进程。这通常发生地足够快以致给我们并发执行地错觉，如下图所示： </p>
<p><img src="https://cdn3.raywenderlich.com/wp-content/uploads/2014/01/Concurrency_vs_Parallelism.png" alt=""></p>
<p>虽然你可以编写代码在 GCD 下并发执行，但 GCD 会决定有多少并行的需求。并行要求并发，但并发并不能保证并行。</p>
<p>更深入的观点是并发实际上是关于构造。当你在脑海中用 <code>GCD</code> 编写代码，你组织你的代码来暴露能同时运行的多个工作片段，以及不能同时运行的那些。如果你想深入此主题，看看 <a href="http://vimeo.com/49718712" target="_blank" rel="external">this excellent talk by Rob Pike</a> 。</p>
<h4 id="Queues-队列"><a href="#Queues-队列" class="headerlink" title="Queues 队列"></a>Queues 队列</h4><p><code>GCD</code> 提供有 dispatch queues 来处理代码块，这些队列管理你提供给 <code>GCD</code> 的任务并用 <code>FIFO</code> 顺序执行这些任务。这就保证了第一个被添加到队列里的任务会是队列中第一个开始的任务，而第二个被添加的任务将第二个开始，如此直到队列的终点。</p>
<p>所有的调度队列（dispatch queues）自身都是线程安全的，你能从多个线程并行的访问它们。 <code>GCD</code> 的优点是显而易见的，即当你了解了调度队列如何为你自己代码的不同部分提供线程安全。关于这一点的关键是选择正确类型的调度队列和正确的调度函数来提交你的工作。</p>
<p>在本节你会看到两种调度队列，都是由 <code>GCD</code> 提供的，然后看一些描述如何用调度函数添加工作到队列的列子。</p>
<h5 id="Serial-Queues-串行队列"><a href="#Serial-Queues-串行队列" class="headerlink" title="Serial Queues 串行队列"></a>Serial Queues 串行队列</h5><p><img src="https://cdn2.raywenderlich.com/wp-content/uploads/2014/01/Serial-Queue-480x272.png" alt=""><br>这些任务的执行时机受到 <code>GCD</code> 的控制；唯一能确保的事情是 <code>GCD</code> 一次只执行一个任务，并且按照我们添加到队列的顺序来执行。</p>
<p>由于在串行队列中不会有两个任务并发运行，因此不会出现同时访问临界区的风险；相对于这些任务来说，这就从竞态条件下保护了临界区。所以如果访问临界区的唯一方式是通过提交到调度队列的任务，那么你就不需要担心临界区的安全问题了。</p>
<h5 id="Concurrent-Queues-并发队列"><a href="#Concurrent-Queues-并发队列" class="headerlink" title="Concurrent Queues 并发队列"></a>Concurrent Queues 并发队列</h5><p>在并发队列中的任务能得到的保证是它们会按照被添加的顺序开始执行，但这就是全部的保证了。任务可能以任意顺序完成，你不会知道何时开始运行下一个任务，或者任意时刻有多少 <code>Block</code> 在运行。再说一遍，这完全取决于 <code>GCD</code> 。</p>
<p>下图展示了一个示例任务执行计划，<code>GCD</code> 管理着四个并发任务： </p>
<p><img src="https://cdn1.raywenderlich.com/wp-content/uploads/2014/01/Concurrent-Queue-480x272.png" alt=""></p>
<p>注意 Block 1,2 和 3 都立马开始运行，一个接一个。在 Block 0 开始后，Block 1等待了好一会儿才开始。同样， Block 3 在 Block 2 之后才开始，但它先于 Block 2 完成。</p>
<p>何时开始一个 <code>Block</code> 完全取决于 <code>GCD</code> 。如果一个 <code>Block</code> 的执行时间与另一个重叠，也是由 <code>GCD</code> 来决定是否将其运行在另一个不同的核心上，如果那个核心可用，否则就用上下文切换的方式来执行不同的 <code>Block</code> 。</p>
<p>有趣的是， <code>GCD</code> 提供给你至少五个特定的队列，可根据队列类型选择使用。</p>
<h4 id="Queue-Types-队列类型"><a href="#Queue-Types-队列类型" class="headerlink" title="Queue Types 队列类型"></a>Queue Types 队列类型</h4><p>首先，系统提供给你一个叫做 主队列（main queue） 的特殊队列。和其它串行队列一样，这个队列中的任务一次只能执行一个。然而，它能保证所有的任务都在主线程执行，而主线程是唯一可用于更新 UI 的线程。这个队列就是用于发生消息给 <code>UIView</code> 或发送通知的。</p>
<p>系统同时提供给你好几个并发队列。它们叫做 全局调度队列（Global Dispatch Queues） 。目前的四个全局队列有着不同的优先级：background、low、default 以及 high。要知道，Apple 的 API 也会使用这些队列，所以你添加的任何任务都不会是这些队列中唯一的任务。</p>
<p>最后，你也可以创建自己的串行队列或并发队列。这就是说，至少有五个队列任你处置：主队列、四个全局调度队列，再加上任何你自己创建的队列。</p>
<p>以上是调度队列的大框架！</p>
<p><code>GCD</code> 的“艺术”归结为选择合适的队列来调度函数以提交你的工作。体验这一点的最好方式是走一遍下边的列子，我们沿途会提供一些一般性的建议。</p>
<h3 id="开始使用"><a href="#开始使用" class="headerlink" title="开始使用"></a>开始使用</h3><p>既然本教程的目标是优化且安全的使用 GCD 调用来自不同线程的代码，那么你将从一个近乎完成的叫做 GooglyPuff 的项目入手。</p>
<p>GooglyPuff 是一个没有优化，线程不安全的应用，它使用 Core Image 的人脸检测 API 来覆盖一对曲棍球眼睛到被检测到的人脸上。对于基本的图像，可以从相机胶卷选择，或用预设好的URL从互联网下载。<br><a href="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/GooglyPuff_Start_1.zip" target="_blank" rel="external">项目地址</a><br>完成项目下载之后，将其解压到某个方便的目录，再用 Xcode 打开它并编译运行。这个应用看起来如下图所示：<br><img src="https://cdn1.raywenderlich.com/wp-content/uploads/2014/01/Workflow1.png" alt=""><br>注意当你选择 Le Internet 选项下载图片时，一个 UIAlertView 过早地弹出。你将在本系列教程地第二部分修复这个问题。</p>
<p>这个项目中有四个有趣的类：</p>
<ol>
<li>PhotoCollectionViewController：它是应用开始的第一个视图控制器。它用缩略图展示所有选定的照片。</li>
<li>PhotoDetailViewController：它执行添加曲棍球眼睛到图像上的逻辑，并用一个 UIScrollView 来显示结果图片。</li>
<li>Photo：这是一个类簇，它根据一个 NSURL 的实例或一个 ALAsset 的实例来实例化照片。这个类提供一个图像、缩略图以及从 URL 下载的状态。</li>
<li>PhotoManager：它管理所有 Photo 的实例.</li>
</ol>
<h3 id="用-dispatch-async-处理后台任务"><a href="#用-dispatch-async-处理后台任务" class="headerlink" title="用 dispatch_async 处理后台任务"></a>用 dispatch_async 处理后台任务</h3><p>回到应用并从你的相机胶卷添加一些照片或使用 Le Internet 选项下载一些。</p>
<p>注意在按下 PhotoCollectionViewController 中的一个 UICollectionViewCell 到生成一个新的 PhotoDetailViewController 之间花了多久时间；你会注意到一个明显的滞后，特别是在比较慢的设备上查看很大的图。</p>
<p>在重载 UIViewController 的 viewDidLoad 时容易加入太多杂波（too much clutter），这通常会引起视图控制器出现前更长的等待。如果可能，最好是卸下一些工作放到后台，如果它们不是绝对必须要运行在加载时间里。</p>
<p>这听起来像是 dispatch_async 能做的事情！</p>
<p>打开 PhotoDetailViewController 并用下面的实现替换 viewDidLoad ：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad </span><br><span class="line">&#123;    </span><br><span class="line">    [<span class="keyword">super</span> viewDidLoad]; </span><br><span class="line">    <span class="built_in">NSAssert</span>(_image, <span class="string">@"Image not set; required to use view controller"</span>); </span><br><span class="line">    <span class="keyword">self</span>.photoImageView.image = _image; </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//Resize if neccessary to ensure it's not pixelated </span></span><br><span class="line">    <span class="keyword">if</span> (_image.size.height &lt;= <span class="keyword">self</span>.photoImageView.bounds.size.height &amp;&amp; </span><br><span class="line">        _image.size.width &lt;= <span class="keyword">self</span>.photoImageView.bounds.size.width) &#123; </span><br><span class="line">        [<span class="keyword">self</span>.photoImageView setContentMode:<span class="built_in">UIViewContentModeCenter</span>]; </span><br><span class="line">    &#125; </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123; <span class="comment">// 1 </span></span><br><span class="line">        <span class="built_in">UIImage</span> *overlayImage = [<span class="keyword">self</span> faceOverlayImageFromImage:_image]; </span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123; <span class="comment">// 2 </span></span><br><span class="line">            [<span class="keyword">self</span> fadeInNewImage:overlayImage]; <span class="comment">// 3 </span></span><br><span class="line">        &#125;); </span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面来说明上面的新代码所做的事：</p>
<ol>
<li>你首先将工作从主线程移到全局线程。因为这是一个 dispatch_async() ，Block 会被异步地提交，意味着调用线程地执行将会继续。这就使得 viewDidLoad 更早地在主线程完成，让加载过程感觉起来更加快速。同时，一个人脸检测过程会启动并将在稍后完成。</li>
<li>在这里，人脸检测过程完成，并生成了一个新的图像。既然你要使用此新图像更新你的 UIImageView ，那么你就添加一个新的 Block 到主线程。记住——你必须总是在主线程访问 UIKit 的类。</li>
<li>最后，你用 fadeInNewImage: 更新 UI ，它执行一个淡入过程切换到新的曲棍球眼睛图像。<br>编译并运行你的应用；选择一个图像然后你会注意到视图控制器加载明显变快，曲棍球眼睛稍微在之后就加上了。这给应用带来了不错的效果，和之前的显示差别巨大。</li>
</ol>
<p>进一步，如果你试着加载一个超大的图像，应用不会在加载视图控制器上“挂住”，这就使得应用具有很好伸缩性。</p>
<p>正如之前提到的， dispatch_async 添加一个 Block 都队列就立即返回了。任务会在之后由 GCD 决定执行。当你需要在后台执行一个基于网络或 CPU 紧张的任务时就使用 dispatch_async ，这样就不会阻塞当前线程。</p>
<p>下面是一个关于在 dispatch_async 上如何以及何时使用不同的队列类型的快速指导：</p>
<ol>
<li>自定义串行队列：当你想串行执行后台任务并追踪它时就是一个好选择。这消除了资源争用，因为你知道一次只有一个任务在执行。注意若你需要来自某个方法的数据，你必须内联另一个 Block 来找回它或考虑使用 dispatch_sync。</li>
<li>主队列（串行）：这是在一个并发队列上完成任务后更新 UI 的共同选择。要这样做，你将在一个 Block 内部编写另一个 Block 。以及，如果你在主队列调用 dispatch_async 到主队列，你能确保这个新任务将在当前方法完成后的某个时间执行。</li>
<li>并发队列：这是在后台执行非 UI 工作的共同选择。</li>
</ol>
<h3 id="使用-dispatch-after-延后工作"><a href="#使用-dispatch-after-延后工作" class="headerlink" title="使用 dispatch_after 延后工作"></a>使用 dispatch_after 延后工作</h3><p>稍微考虑一下应用的 UX 。是否用户第一次打开应用时会困惑于不知道做什么？你是这样吗？ :]</p>
<p>如果用户的 PhotoManager 里还没有任何照片，那么显示一个提示会是个好主意！然而，你同样要考虑用户的眼睛会如何在主屏幕上浏览：如果你太快的显示一个提示，他们的眼睛还徘徊在视图的其它部分上，他们很可能会错过它。</p>
<p>显示提示之前延迟一秒钟就足够捕捉到用户的注意，他们此时已经第一次看过了应用。</p>
<p>添加如下代码到到 PhotoCollectionViewController.m 中 showOrHideNavPrompt 的废止实现里：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)showOrHideNavPrompt </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">NSUInteger</span> count = [[PhotoManager sharedManager] photos].count; </span><br><span class="line">    <span class="keyword">double</span> delayInSeconds = <span class="number">1.0</span>; </span><br><span class="line">    dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t)(delayInSeconds * <span class="built_in">NSEC_PER_SEC</span>)); <span class="comment">// 1  </span></span><br><span class="line">    dispatch_after(popTime, dispatch_get_main_queue(), ^(<span class="keyword">void</span>)&#123; <span class="comment">// 2  </span></span><br><span class="line">        <span class="keyword">if</span> (!count) &#123; </span><br><span class="line">            [<span class="keyword">self</span>.navigationItem setPrompt:<span class="string">@"Add photos with faces to Googlyify them!"</span>]; </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">            [<span class="keyword">self</span>.navigationItem setPrompt:<span class="literal">nil</span>]; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>showOrHideNavPrompt 在 viewDidLoad 中执行，以及 UICollectionView 被重新加载的任何时候。按照注释数字顺序看看：</p>
<ol>
<li>你声明了一个变量指定要延迟的时长。</li>
<li>然后等待 delayInSeconds 给定的时长，再异步地添加一个 Block 到主线程。</li>
</ol>
<p>编译并运行应用。应该有一个轻微地延迟，这有助于抓住用户的注意力并展示所要做的事情。</p>
<p>dispatch_after 工作起来就像一个延迟版的 dispatch_async 。你依然不能控制实际的执行时间，且一旦 dispatch_after 返回也就不能再取消它。</p>
<p>不知道何时适合使用 dispatch_after ？</p>
<ol>
<li>自定义串行队列：在一个自定义串行队列上使用 dispatch_after 要小心。你最好坚持使用主队列。</li>
<li>主队列（串行）：是使用 dispatch_after 的好选择；Xcode 提供了一个不错的自动完成模版。</li>
<li>并发队列：在并发队列上使用 dispatch_after 也要小心；你会这样做就比较罕见。还是在主队列做这些操作吧。</li>
</ol>
<h3 id="让你的单例线程安全"><a href="#让你的单例线程安全" class="headerlink" title="让你的单例线程安全"></a>让你的单例线程安全</h3><p>单例，不论喜欢还是讨厌，它们在 iOS 上的流行情况就像网上的猫。 :]</p>
<p>一个常见的担忧是它们常常不是线程安全的。这个担忧十分合理，基于它们的用途：单例常常被多个控制器同时访问。</p>
<p>单例的线程担忧范围从初始化开始，到信息的读和写。PhotoManager 类被实现为单例——它在目前的状态下就会被这些问题所困扰。要看看事情如何很快地失去控制，你将在单例实例上创建一个控制好的竞态条件。</p>
<p>导航到 PhotoManager.m 并找到 sharedManager ；它看起来如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)sharedManager     </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">static</span> PhotoManager *sharedPhotoManager = <span class="literal">nil</span>; </span><br><span class="line">    <span class="keyword">if</span> (!sharedPhotoManager) &#123; </span><br><span class="line">        sharedPhotoManager = [[PhotoManager alloc] init]; </span><br><span class="line">        sharedPhotoManager-&gt;_photosArray = [<span class="built_in">NSMutableArray</span> array]; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> sharedPhotoManager; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当前状态下，代码相当简单；你创建了一个单例并初始化一个叫做 photosArray 的 NSMutableArray 属性。</p>
<p>然而，if 条件分支不是线程安全的；如果你多次调用这个方法，有一个可能性是在某个线程（就叫它线程A）上进入 if 语句块并可能在 sharedPhotoManager 被分配内存前发生一个上下文切换。然后另一个线程（线程B）可能进入 if ，分配单例实例的内存，然后退出。</p>
<p>当系统上下文切换回线程A，你会分配另外一个单例实例的内存，然后退出。在那个时间点，你有了两个单例的实例——很明显这不是你想要的（译者注：这还能叫单例吗？）！</p>
<p>要强制这个（竞态）条件发生，替换 PhotoManager.m 中的 sharedManager 为下面的实现：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)sharedManager   </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">static</span> PhotoManager *sharedPhotoManager = <span class="literal">nil</span>; </span><br><span class="line">    <span class="keyword">if</span> (!sharedPhotoManager) &#123; </span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; </span><br><span class="line">        sharedPhotoManager = [[PhotoManager alloc] init]; </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Singleton has memory address at: %@"</span>, sharedPhotoManager); </span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; </span><br><span class="line">        sharedPhotoManager-&gt;_photosArray = [<span class="built_in">NSMutableArray</span> array]; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> sharedPhotoManager; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码中你用 NSThread 的 sleepForTimeInterval: 类方法来强制发生一个上下文切换。</p>
<p>打开 AppDelegate.m 并添加如下代码到 application:didFinishLaunchingWithOptions: 的最开始处：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123; </span><br><span class="line">    [PhotoManager sharedManager]; </span><br><span class="line">&#125;); </span><br><span class="line"> </span><br><span class="line"><span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123; </span><br><span class="line">    [PhotoManager sharedManager]; </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>这里创建了多个异步并发调用来实例化单例，然后引发上面描述的竞态条件。</p>
<p>编译并运行项目；查看控制台输出，你会看到多个单例被实例化，如下所示：<br><img src="http://www.raywenderlich.com/wp-content/uploads/2014/01/NSLog-Race-Condition.png" alt=""><br>注意到这里有好几行显示着不同地址的单例实例。这明显违背了单例的目的，对吧？</p>
<p>这个输出向你展示了临界区被执行多次，而它只应该执行一次。现在，固然是你自己强制这样的状况发生，但你可以想像一下这个状况会怎样在无意间发生。</p>
<p>注意：基于其它你无法控制的系统事件，NSLog 的数量有时会显示多个。线程问题极其难以调试，因为它们往往难以重现。<br>要纠正这个状况，实例化代码应该只执行一次，并阻塞其它实例在 if 条件的临界区运行。这刚好就是 dispatch_once 能做的事。</p>
<p>在单例初始化方法中用 dispatch_once 取代 if 条件判断，如下所示：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)sharedManager </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">static</span> PhotoManager *sharedPhotoManager = <span class="literal">nil</span>; </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; </span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123; </span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; </span><br><span class="line">        sharedPhotoManager = [[PhotoManager alloc] init]; </span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Singleton has memory address at: %@"</span>, sharedPhotoManager); </span><br><span class="line">        [<span class="built_in">NSThread</span> sleepForTimeInterval:<span class="number">2</span>]; </span><br><span class="line">        sharedPhotoManager-&gt;_photosArray = [<span class="built_in">NSMutableArray</span> array]; </span><br><span class="line">    &#125;); </span><br><span class="line">    <span class="keyword">return</span> sharedPhotoManager; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译并运行你的应用；查看控制台输出，你会看到有且仅有一个单例的实例——这就是你对单例的期望！:]</p>
<p>现在你已经明白了防止竞态条件的重要性，从 AppDelegate.m 中移除 dispatch_async 语句，并用下面的实现替换 PhotoManager 单例的初始化：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)sharedManager </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">static</span> PhotoManager *sharedPhotoManager = <span class="literal">nil</span>; </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; </span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123; </span><br><span class="line">        sharedPhotoManager = [[PhotoManager alloc] init]; </span><br><span class="line">        sharedPhotoManager-&gt;_photosArray = [<span class="built_in">NSMutableArray</span> array]; </span><br><span class="line">    &#125;); </span><br><span class="line">    <span class="keyword">return</span> sharedPhotoManager; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>dispatch_once() 以线程安全的方式执行且仅执行其代码块一次。试图访问临界区（即传递给 dispatch_once 的代码）的不同的线程会在临界区已有一个线程的情况下被阻塞，直到临界区完成为止。<br><img src="https://cdn1.raywenderlich.com/wp-content/uploads/2014/01/Highlander_dispatch_once-480x274.png" alt=""><br>需要记住的是，这只是让访问共享实例线程安全。它绝对没有让类本身线程安全。类中可能还有其它竞态条件，例如任何操纵内部数据的情况。这些需要用其它方式来保证线程安全，例如同步访问数据，你将在下面几个小节看到。</p>
<h3 id="处理读者与写者问题"><a href="#处理读者与写者问题" class="headerlink" title="处理读者与写者问题"></a>处理读者与写者问题</h3><p>线程安全实例不是处理单例时的唯一问题。如果单例属性表示一个可变对象，那么你就需要考虑是否那个对象自身线程安全。</p>
<p>如果问题中的这个对象是一个 Foundation 容器类，那么答案是——“很可能不安全”！Apple 维护一个有用且有些心寒的列表，众多的 Foundation 类都不是线程安全的。 NSMutableArray，已用于你的单例，正在那个列表里休息。</p>
<p>虽然许多线程可以同时读取 NSMutableArray 的一个实例而不会产生问题，但当一个线程正在读取时让另外一个线程修改数组就是不安全的。你的单例在目前的状况下不能预防这种情况的发生。</p>
<p>要分析这个问题，看看 PhotoManager.m 中的 addPhoto:，转载如下：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addPhoto:(Photo *)photo </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (photo) &#123; </span><br><span class="line">        [_photosArray addObject:photo]; </span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123; </span><br><span class="line">            [<span class="keyword">self</span> postContentAddedNotification]; </span><br><span class="line">        &#125;); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是一个写方法，它修改一个私有可变数组对象。<br>现在看看 photos ，转载如下：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)photos </span><br><span class="line">&#123; </span><br><span class="line">  <span class="keyword">return</span> [<span class="built_in">NSArray</span> arrayWithArray:_photosArray]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这是所谓的读方法，它读取可变数组。它为调用者生成一个不可变的拷贝，防止调用者不当地改变数组，但这不能提供任何保护来对抗当一个线程调用读方法 photos 的同时另一个线程调用写方法 addPhoto: 。</p>
<p>这就是软件开发中经典的读者写者问题。GCD 通过用 dispatch barriers 创建一个读者写者锁 提供了一个优雅的解决方案。</p>
<p>Dispatch barriers 是一组函数，在并发队列上工作时扮演一个串行式的瓶颈。使用 GCD 的障碍（barrier）API 确保提交的 Block 在那个特定时间上是指定队列上唯一被执行的条目。这就意味着所有的先于调度障碍提交到队列的条目必能在这个 Block 执行前完成。</p>
<p>当这个 Block 的时机到达，调度障碍执行这个 Block 并确保在那个时间里队列不会执行任何其它 Block 。一旦完成，队列就返回到它默认的实现状态。 GCD 提供了同步和异步两种障碍函数。</p>
<p>下图显示了障碍函数对多个异步队列的影响：<br><img src="http://www.raywenderlich.com/wp-content/uploads/2014/01/Dispatch-Barrier.png" alt=""><br>注意到正常部分的操作就如同一个正常的并发队列。但当障碍执行时，它本质上就如同一个串行队列。也就是，障碍是唯一在执行的事物。在障碍完成后，队列回到一个正常并发队列的样子。</p>
<p>下面是你何时会——和不会——使用障碍函数的情况：</p>
<ol>
<li>自定义串行队列：一个很坏的选择；障碍不会有任何帮助，因为不管怎样，一个串行队列一次都只执行一个操作。</li>
<li>全局并发队列：要小心；这可能不是最好的主意，因为其它系统可能在使用队列而且你不能垄断它们只为你自己的目的。</li>
<li>自定义并发队列：这对于原子或临界区代码来说是极佳的选择。任何你在设置或实例化的需要线程安全的事物都是使用障碍的最佳候选。</li>
</ol>
<p>由于上面唯一像样的选择是自定义并发队列，你将创建一个你自己的队列去处理你的障碍函数并分开读和写函数。且这个并发队列将允许多个多操作同时进行。</p>
<p>打开 PhotoManager.m，添加如下私有属性到类扩展中：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">PhotoManager</span> () </span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>,<span class="keyword">strong</span>,<span class="keyword">readonly</span>) <span class="built_in">NSMutableArray</span> *photosArray; </span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">dispatch_queue_t</span> concurrentPhotoQueue; <span class="comment">///&lt; Add this </span></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure></p>
<p>找到 addPhoto: 并用下面的实现替换它：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)addPhoto:(Photo *)photo </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">if</span> (photo) &#123; <span class="comment">// 1 </span></span><br><span class="line">        dispatch_barrier_async(<span class="keyword">self</span>.concurrentPhotoQueue, ^&#123; <span class="comment">// 2  </span></span><br><span class="line">            [_photosArray addObject:photo]; <span class="comment">// 3 </span></span><br><span class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123; <span class="comment">// 4 </span></span><br><span class="line">                [<span class="keyword">self</span> postContentAddedNotification];  </span><br><span class="line">            &#125;); </span><br><span class="line">        &#125;); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你新写的函数是这样工作的：</p>
<ol>
<li>在执行下面所有的工作前检查是否有合法的相片。</li>
<li>添加写操作到你的自定义队列。当临界区在稍后执行时，这将是你队列中唯一执行的条目。</li>
<li>这是添加对象到数组的实际代码。由于它是一个障碍 Block ，这个 Block 永远不会同时和其它 Block 一起在 concurrentPhotoQueue 中执行。</li>
<li>最后你发送一个通知说明完成了添加图片。这个通知将在主线程被发送因为它将会做一些 UI 工作，所以在此为了通知，你异步地调度另一个任务到主线程。<br>这就处理了写操作，但你还需要实现 photos 读方法并实例化 concurrentPhotoQueue 。</li>
</ol>
<p>在写者打扰的情况下，要确保线程安全，你需要在 concurrentPhotoQueue 队列上执行读操作。既然你需要从函数返回，你就不能异步调度到队列，因为那样在读者函数返回之前不一定运行。</p>
<p>在这种情况下，dispatch_sync 就是一个绝好的候选。</p>
<p>dispatch_sync() 同步地提交工作并在返回前等待它完成。使用 dispatch_sync 跟踪你的调度障碍工作，或者当你需要等待操作完成后才能使用 Block 处理过的数据。如果你使用第二种情况做事，你将不时看到一个 __block 变量写在 dispatch_sync 范围之外，以便返回时在 dispatch_sync 使用处理过的对象。</p>
<p>但你需要很小心。想像如果你调用 dispatch_sync 并放在你已运行着的当前队列。这会导致死锁，因为调用会一直等待直到 Block 完成，但 Block 不能完成（它甚至不会开始！），直到当前已经存在的任务完成，而当前任务无法完成！这将迫使你自觉于你正从哪个队列调用——以及你正在传递进入哪个队列。</p>
<p>下面是一个快速总览，关于在何时以及何处使用 dispatch_sync ：</p>
<ol>
<li>自定义串行队列：在这个状况下要非常小心！如果你正运行在一个队列并调用 dispatch_sync 放在同一个队列，那你就百分百地创建了一个死锁。</li>
<li>主队列（串行）：同上面的理由一样，必须非常小心！这个状况同样有潜在的导致死锁的情况。</li>
<li>并发队列：这才是做同步工作的好选择，不论是通过调度障碍，或者需要等待一个任务完成才能执行进一步处理的情况。</li>
</ol>
<p>继续在 PhotoManager.m 上工作，用下面的实现替换 photos ：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="built_in">NSArray</span> *)photos </span><br><span class="line">&#123; </span><br><span class="line">    __block <span class="built_in">NSArray</span> *array; <span class="comment">// 1 </span></span><br><span class="line">    <span class="built_in">dispatch_sync</span>(<span class="keyword">self</span>.concurrentPhotoQueue, ^&#123; <span class="comment">// 2 </span></span><br><span class="line">        array = [<span class="built_in">NSArray</span> arrayWithArray:_photosArray]; <span class="comment">// 3 </span></span><br><span class="line">    &#125;); </span><br><span class="line">    <span class="keyword">return</span> array; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这就是你的读函数。按顺序看看编过号的注释，有这些：</p>
<ol>
<li>__block 关键字允许对象在 Block 内可变。没有它，array 在 Block 内部就只是只读的，你的代码甚至不能通过编译。</li>
<li>在 concurrentPhotoQueue 上同步调度来执行读操作。</li>
<li>将相片数组存储在 array 内并返回它。</li>
</ol>
<p>最后，你需要实例化你的 concurrentPhotoQueue 属性。修改 sharedManager 以便像下面这样初始化队列：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">+ (<span class="keyword">instancetype</span>)sharedManager </span><br><span class="line">&#123; </span><br><span class="line">    <span class="keyword">static</span> PhotoManager *sharedPhotoManager = <span class="literal">nil</span>; </span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken; </span><br><span class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123; </span><br><span class="line">        sharedPhotoManager = [[PhotoManager alloc] init]; </span><br><span class="line">        sharedPhotoManager-&gt;_photosArray = [<span class="built_in">NSMutableArray</span> array]; </span><br><span class="line"> </span><br><span class="line">        <span class="comment">// ADD THIS: </span></span><br><span class="line">        sharedPhotoManager-&gt;_concurrentPhotoQueue = dispatch_queue_create(<span class="string">"com.selander.GooglyPuff.photoQueue"</span>, </span><br><span class="line">                                                    DISPATCH_QUEUE_CONCURRENT);  </span><br><span class="line">    &#125;); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> sharedPhotoManager; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里使用 dispatch_queue_create 初始化 concurrentPhotoQueue 为一个并发队列。第一个参数是反向DNS样式命名惯例；确保它是描述性的，将有助于调试。第二个参数指定你的队列是串行还是并发。</p>
<p>注意：当你在网上搜索例子时，你会经常看人们传递 0 或者 NULL 给 dispatch_queue_create 的第二个参数。这是一个创建串行队列的过时方式；明确你的参数总是更好。<br>恭喜——你的 PhotoManager 单例现在是线程安全的了。不论你在何处或怎样读或写你的照片，你都有这样的自信，即它将以安全的方式完成，不会出现任何惊吓。</p>
<h3 id="A-Visual-Review-of-Queueing-队列的虚拟回顾"><a href="#A-Visual-Review-of-Queueing-队列的虚拟回顾" class="headerlink" title="A Visual Review of Queueing 队列的虚拟回顾"></a>A Visual Review of Queueing 队列的虚拟回顾</h3><p>依然没有 100% 地掌握 GCD 的要领？确保你可以使用 GCD 函数轻松地创建简单的例子，使用断点和 NSLog 语句保证自己明白当下发生的情况。</p>
<p>我在下面提供了两个 GIF动画来帮助你巩固对 dispatch_async 和 dispatch_sync 的理解。包含在每个 GIF 中的代码可以提供视觉辅助；仔细注意 GIF 左边显示代码断点的每一步，以及右边相关队列的状态。</p>
<h4 id="dispatch-sync-回顾"><a href="#dispatch-sync-回顾" class="headerlink" title="dispatch_sync 回顾"></a>dispatch_sync 回顾</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad </span><br><span class="line">&#123; </span><br><span class="line">  [<span class="keyword">super</span> viewDidLoad]; </span><br><span class="line"> </span><br><span class="line">  <span class="built_in">dispatch_sync</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123; </span><br><span class="line"> </span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"First Log"</span>); </span><br><span class="line"> </span><br><span class="line">  &#125;); </span><br><span class="line"> </span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"Second Log"</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/01/dispatch_sync_in_action.gif" alt=""><br>下面是图中几个步骤的说明：</p>
<ol>
<li>主队列一路按顺序执行任务——接着是一个实例化 UIViewController 的任务，其中包含了 viewDidLoad 。</li>
<li>viewDidLoad 在主线程执行。</li>
<li>主线程目前在 viewDidLoad 内，正要到达 dispatch_sync 。</li>
<li>dispatch_sync Block 被添加到一个全局队列中，将在稍后执行。进程将在主线程挂起直到该 Block 完成。同时，全局队列并发处理任务；要记得 Block 在全局队列中将按照 FIFO 顺序出列，但可以并发执行。</li>
<li>全局队列处理 dispatch_sync Block 加入之前已经出现在队列中的任务。</li>
<li>终于，轮到 dispatch_sync Block 。</li>
<li>这个 Block 完成，因此主线程上的任务可以恢复。</li>
<li>viewDidLoad 方法完成，主队列继续处理其他任务。</li>
</ol>
<p>dispatch_sync 添加任务到一个队列并等待直到任务完成。dispatch_async 做类似的事情，但不同之处是它不会等待任务的完成，而是立即继续“调用线程”的其它任务。</p>
<h4 id="dispatch-async-回顾"><a href="#dispatch-async-回顾" class="headerlink" title="dispatch_async 回顾"></a>dispatch_async 回顾</h4><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad </span><br><span class="line">&#123; </span><br><span class="line">  [<span class="keyword">super</span> viewDidLoad]; </span><br><span class="line"> </span><br><span class="line">  <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123; </span><br><span class="line"> </span><br><span class="line">      <span class="built_in">NSLog</span>(<span class="string">@"First Log"</span>); </span><br><span class="line"> </span><br><span class="line">  &#125;); </span><br><span class="line"> </span><br><span class="line">  <span class="built_in">NSLog</span>(<span class="string">@"Second Log"</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/01/dispatch_async_in_action.gif" alt=""></p>
<ol>
<li>主队列一路按顺序执行任务——接着是一个实例化 UIViewController 的任务，其中包含了 viewDidLoad 。</li>
<li>viewDidLoad 在主线程执行。</li>
<li>主线程目前在 viewDidLoad 内，正要到达 dispatch_async 。</li>
<li>dispatch_async Block 被添加到一个全局队列中，将在稍后执行。</li>
<li>viewDidLoad 在添加 dispatch_async 到全局队列后继续进行，主线程把注意力转向剩下的任务。同时，全局队列并发地处理它未完成地任务。记住 Block 在全局队列中将按照 FIFO 顺序出列，但可以并发执行。</li>
<li>添加到 dispatch_async 的代码块开始执行。</li>
<li>dispatch_async Block 完成，两个 NSLog 语句将它们的输出放在控制台上。</li>
</ol>
<p>在这个特定的实例中，第二个 NSLog 语句执行，跟着是第一个 NSLog 语句。并不总是这样——着取决于给定时刻硬件正在做的事情，而且你无法控制或知晓哪个语句会先执行。“第一个” NSLog 在某些调用情况下会第一个执行。</p>
<h3 id="准备下一步"><a href="#准备下一步" class="headerlink" title="准备下一步"></a>准备下一步</h3><p>在本教程中，你学习了如何让你的代码线程安全，以及在执行 CPU 密集型任务时如何保持主线程的响应性。</p>
<p>你可以下载 <a href="http://www.raywenderlich.com/wp-content/uploads/2014/01/GooglyPuff_End_1.zip" target="_blank" rel="external">GooglyPuff 项目</a>，它包含了目前所有本教程中编写的实现。在本教程的第二部分，你将继续改进这个项目。</p>
<p>如果你计划优化你自己的应用，那你应该用 Instruments 中的 Time Profile 模版分析你的工作。对这个工具的使用超出了本教程的范围，你可以看看 <a href="https://www.raywenderlich.com/?p=23037" target="_blank" rel="external">如何使用Instruments</a> 来得到一个很好的概述。</p>
<p>同时请确保在真实设备上分析，而在模拟器上测试会对程序速度产生非常不准确的印象。</p>
<p>现在你已经学到超过你想像的关于并发、线程以及GCD 如何工作的知识。通过在初始化时利用 dispatch_once，你创建了一个线程安全的 PhotoManager 单例，而且你通过使用 dispatch_barrier_async 和 dispatch_sync 的组合使得对 Photos 数组的读取和写入都变得线程安全了。</p>
<p>除了上面这些，你还通过利用 dispatch_after 来延迟显示提示信息，以及利用 dispatch_async 将 CPU 密集型任务从 ViewController 的初始化过程中剥离出来异步执行，达到了增强应用的用户体验的目的。</p>
<p>如果你一直跟着第一部分的教程在写代码，那你可以继续你的工程。但如果你没有完成第一部分的工作，或者不想重用你的工程，你可以下载<a href="http://www.raywenderlich.com/wp-content/uploads/2014/01/GooglyPuff_End_1.zip" target="_blank" rel="external">第一部分最终的代码</a>。</p>
<p>那就让我们来更深入地探索 GCD 吧！</p>
<h3 id="纠正过早弹出的提示"><a href="#纠正过早弹出的提示" class="headerlink" title="纠正过早弹出的提示"></a>纠正过早弹出的提示</h3><p>你可能已经注意到当你尝试用 Le Internet 选项来添加图片时，一个 UIAlertView 会在图片下载完成之前就弹出，如下如所示： </p>
<p><img src="http://www.raywenderlich.com/wp-content/uploads/2014/01/Screen-Shot-2014-01-17-at-5.49.51-PM.png" alt=""></p>
<p>问题的症结在 PhotoManagers 的 downloadPhotoWithCompletionBlock: 里，它目前的实现如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock</span><br><span class="line">&#123;</span><br><span class="line">    __block <span class="built_in">NSError</span> *error;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSURL</span> *url;</span><br><span class="line">        <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                url = [<span class="built_in">NSURL</span> URLWithString:kOverlyAttachedGirlfriendURLString];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                url = [<span class="built_in">NSURL</span> URLWithString:kSuccessKidURLString];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                url = [<span class="built_in">NSURL</span> URLWithString:kLotsOfFacesURLString];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        Photo *photo = [[Photo alloc] initwithURL:url</span><br><span class="line">                              withCompletionBlock:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *_error) &#123;</span><br><span class="line">                                  <span class="keyword">if</span> (_error) &#123;</span><br><span class="line">                                      error = _error;</span><br><span class="line">                                  &#125;</span><br><span class="line">                              &#125;];</span><br><span class="line"> </span><br><span class="line">        [[PhotoManager sharedManager] addPhoto:photo];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">        completionBlock(error);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在方法的最后你调用了 completionBlock ——因为此时你假设所有的照片都已下载完成。但很不幸，此时并不能保证所有的下载都已完成。</p>
<p>Photo 类的实例方法用某个 URL 开始下载某个文件并立即返回，但此时下载并未完成。换句话说，当 downloadPhotoWithCompletionBlock: 在其末尾调用 completionBlock 时，它就假设了它自己所使用的方法全都是同步的，而且每个方法都完成了它们的工作。</p>
<p>然而，-[Photo initWithURL:withCompletionBlock:] 是异步执行的，会立即返回——所以这种方式行不通。</p>
<p>因此，只有在所有的图像下载任务都调用了它们自己的 Completion Block 之后，downloadPhotoWithCompletionBlock: 才能调用它自己的 completionBlock 。问题是：你该如何监控并发的异步事件？你不知道它们何时完成，而且它们完成的顺序完全是不确定的。</p>
<p>或许你可以写一些比较 Hacky 的代码，用多个布尔值来记录每个下载的完成情况，但这样做就缺失了扩展性，而且说实话，代码会很难看。</p>
<p>幸运的是， 解决这种对多个异步任务的完成进行监控的问题，恰好就是设计 dispatch_group 的目的。</p>
<h3 id="Dispatch-Groups（调度组）"><a href="#Dispatch-Groups（调度组）" class="headerlink" title="Dispatch Groups（调度组）"></a>Dispatch Groups（调度组）</h3><p>Dispatch Group 会在整个组的任务都完成时通知你。这些任务可以是同步的，也可以是异步的，即便在不同的队列也行。而且在整个组的任务都完成时，Dispatch Group 可以用同步的或者异步的方式通知你。因为要监控的任务在不同队列，那就用一个 dispatch_group_t 的实例来记下这些不同的任务。</p>
<p>当组中所有的事件都完成时，GCD 的 API 提供了两种通知方式。</p>
<p>第一种是 dispatch_group_wait ，它会阻塞当前线程，直到组里面所有的任务都完成或者等到某个超时发生。这恰好是你目前所需要的。</p>
<p>打开 PhotoManager.m，用下列实现替换 downloadPhotosWithCompletionBlock:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123; <span class="comment">// 1</span></span><br><span class="line"> </span><br><span class="line">        __block <span class="built_in">NSError</span> *error;</span><br><span class="line">        dispatch_group_t downloadGroup = dispatch_group_create(); <span class="comment">// 2</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="built_in">NSURL</span> *url;</span><br><span class="line">            <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    url = [<span class="built_in">NSURL</span> URLWithString:kOverlyAttachedGirlfriendURLString];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    url = [<span class="built_in">NSURL</span> URLWithString:kSuccessKidURLString];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    url = [<span class="built_in">NSURL</span> URLWithString:kLotsOfFacesURLString];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            dispatch_group_enter(downloadGroup); <span class="comment">// 3</span></span><br><span class="line">            Photo *photo = [[Photo alloc] initwithURL:url</span><br><span class="line">                                  withCompletionBlock:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *_error) &#123;</span><br><span class="line">                                      <span class="keyword">if</span> (_error) &#123;</span><br><span class="line">                                          error = _error;</span><br><span class="line">                                      &#125;</span><br><span class="line">                                      dispatch_group_leave(downloadGroup); <span class="comment">// 4</span></span><br><span class="line">                                  &#125;];</span><br><span class="line"> </span><br><span class="line">            [[PhotoManager sharedManager] addPhoto:photo];</span><br><span class="line">        &#125;</span><br><span class="line">        dispatch_group_wait(downloadGroup, DISPATCH_TIME_FOREVER); <span class="comment">// 5</span></span><br><span class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123; <span class="comment">// 6</span></span><br><span class="line">            <span class="keyword">if</span> (completionBlock) &#123; <span class="comment">// 7</span></span><br><span class="line">                completionBlock(error);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照注释的顺序，你会看到：</p>
<ol>
<li><p>因为你在使用的是同步的 dispatch_group_wait ，它会阻塞当前线程，所以你要用 dispatch_async 将整个方法放入后台队列以避免阻塞主线程。</p>
</li>
<li><p>创建一个新的 Dispatch Group，它的作用就像一个用于未完成任务的计数器。</p>
</li>
<li><p>dispatch_group_enter 手动通知 Dispatch Group 任务已经开始。你必须保证 dispatch_group_enter 和 dispatch_group_leave 成对出现，否则你可能会遇到诡异的崩溃问题。</p>
</li>
<li><p>手动通知 Group 它的工作已经完成。再次说明，你必须要确保进入 Group 的次数和离开 Group 的次数相等。</p>
</li>
<li><p>dispatch_group_wait 会一直等待，直到任务全部完成或者超时。如果在所有任务完成前超时了，该函数会返回一个非零值。你可以对此返回值做条件判断以确定是否超出等待周期；然而，你在这里用 DISPATCH_TIME_FOREVER 让它永远等待。它的意思，勿庸置疑就是，永－远－等－待！这样很好，因为图片的创建工作总是会完成的。</p>
</li>
<li><p>此时此刻，你已经确保了，要么所有的图片任务都已完成，要么发生了超时。然后，你在主线程上运行 completionBlock 回调。这会将工作放到主线程上，并在稍后执行。</p>
</li>
<li><p>最后，检查 completionBlock 是否为 nil，如果不是，那就运行它。</p>
</li>
</ol>
<p>编译并运行你的应用，尝试下载多个图片，观察你的应用是在何时运行 completionBlock 的。</p>
<blockquote>
<p>注意：如果你是在真机上运行应用，而且网络活动发生得太快以致难以观察 completionBlock 被调用的时刻，那么你可以在 Settings 应用里的开发者相关部分里打开一些网络设置，以确保代码按照我们所期望的那样工作。只需去往 Network Link Conditioner 区，开启它，再选择一个 Profile，“Very Bad Network” 就不错。<br>如果你是在模拟器里运行应用，你可以使用 来自 GitHub 的 <a href="http://nshipster.com/network-link-conditioner/" target="_blank" rel="external">Network Link Conditioner</a> 来改变网络速度。它会成为你工具箱中的一个好工具，因为它强制你研究你的应用在连接速度并非最佳的情况下会变成什么样。</p>
</blockquote>
<p>目前为止的解决方案还不错，但是总体来说，如果可能，最好还是要避免阻塞线程。你的下一个任务是重写一些方法，以便当所有下载任务完成时能异步通知你。</p>
<p>在我们转向另外一种使用 Dispatch Group 的方式之前，先看一个简要的概述，关于何时以及怎样使用有着不同的队列类型的 Dispatch Group ：</p>
<ol>
<li><p>自定义串行队列：它很适合当一组任务完成时发出通知。</p>
</li>
<li><p>主队列（串行）：它也很适合这样的情况。但如果你要同步地等待所有工作地完成，那你就不应该使用它，因为你不能阻塞主线程。然而，异步模型是一个很有吸引力的能用于在几个较长任务（例如网络调用）完成后更新 UI 的方式。</p>
</li>
<li><p>并发队列：它也很适合 Dispatch Group 和完成时通知。</p>
</li>
</ol>
<h3 id="Dispatch-Group，第二种方式"><a href="#Dispatch-Group，第二种方式" class="headerlink" title="Dispatch Group，第二种方式"></a>Dispatch Group，第二种方式</h3><p>上面的一切都很好，但在另一个队列上异步调度然后使用 dispatch_group_wait 来阻塞实在显得有些笨拙。是的，还有另一种方式……</p>
<p>在 PhotoManager.m 中找到 downloadPhotosWithCompletionBlock: 方法，用下面的实现替换它：<br><figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    __block <span class="built_in">NSError</span> *error;</span><br><span class="line">    dispatch_group_t downloadGroup = dispatch_group_create(); </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSInteger</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">NSURL</span> *url;</span><br><span class="line">        <span class="keyword">switch</span> (i) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                url = [<span class="built_in">NSURL</span> URLWithString:kOverlyAttachedGirlfriendURLString];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                url = [<span class="built_in">NSURL</span> URLWithString:kSuccessKidURLString];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                url = [<span class="built_in">NSURL</span> URLWithString:kLotsOfFacesURLString];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        dispatch_group_enter(downloadGroup); <span class="comment">// 2</span></span><br><span class="line">        Photo *photo = [[Photo alloc] initwithURL:url</span><br><span class="line">                              withCompletionBlock:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *_error) &#123;</span><br><span class="line">                                  <span class="keyword">if</span> (_error) &#123;</span><br><span class="line">                                      error = _error;</span><br><span class="line">                                  &#125;</span><br><span class="line">                                  dispatch_group_leave(downloadGroup); <span class="comment">// 3</span></span><br><span class="line">                              &#125;];</span><br><span class="line"> </span><br><span class="line">        [[PhotoManager sharedManager] addPhoto:photo];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^&#123; <span class="comment">// 4</span></span><br><span class="line">        <span class="keyword">if</span> (completionBlock) &#123;</span><br><span class="line">            completionBlock(error);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面解释新的异步方法如何工作：</p>
<ol>
<li><p>在新的实现里，因为你没有阻塞主线程，所以你并不需要将方法包裹在 async 调用中。</p>
</li>
<li><p>同样的 enter 方法，没做任何修改。</p>
</li>
<li><p>同样的 leave 方法，也没做任何修改。</p>
</li>
<li><p>dispatch_group_notify 以异步的方式工作。当 Dispatch Group 中没有任何任务时，它就会执行其代码，那么 completionBlock 便会运行。你还指定了运行 completionBlock 的队列，此处，主队列就是你所需要的。</p>
</li>
</ol>
<p>对于这个特定的工作，上面的处理明显更清晰，而且也不会阻塞任何线程。</p>
<h3 id="太多并发带来的风险"><a href="#太多并发带来的风险" class="headerlink" title="太多并发带来的风险"></a>太多并发带来的风险</h3><p>既然你的工具箱里有了这些新工具，你大概做任何事情都想使用它们，对吧？ </p>
<p>看看 PhotoManager 中的 downloadPhotosWithCompletionBlock 方法。你可能已经注意到这里的 for 循环，它迭代三次，下载三个不同的图片。你的任务是尝试让 for 循环并发运行，以提高其速度。</p>
<p>dispatch_apply 刚好可用于这个任务。</p>
<p>dispatch_apply 表现得就像一个 for 循环，但它能并发地执行不同的迭代。这个函数是同步的，所以和普通的 for 循环一样，它只会在所有工作都完成后才会返回。</p>
<p>当在 Block 内计算任何给定数量的工作的最佳迭代数量时，必须要小心，因为过多的迭代和每个迭代只有少量的工作会导致大量开销以致它能抵消任何因并发带来的收益。而被称为跨越式（striding）的技术可以在此帮到你，即通过在每个迭代里多做几个不同的工作。</p>
<p>那何时才适合用 dispatch_apply 呢？</p>
<ol>
<li><p>自定义串行队列：串行队列会完全抵消 dispatch_apply 的功能；你还不如直接使用普通的 for 循环。</p>
</li>
<li><p>主队列（串行）：与上面一样，在串行队列上不适合使用 dispatch_apply 。还是用普通的 for 循环吧。</p>
</li>
<li><p>并发队列：对于并发循环来说是很好选择，特别是当你需要追踪任务的进度时。</p>
</li>
</ol>
<p>回到 downloadPhotosWithCompletionBlock: 并用下列实现替换它：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)downloadPhotosWithCompletionBlock:(BatchPhotoDownloadingCompletionBlock)completionBlock </span><br><span class="line">&#123; </span><br><span class="line">    __block <span class="built_in">NSError</span> *error; </span><br><span class="line">    dispatch_group_t downloadGroup = dispatch_group_create(); </span><br><span class="line"> </span><br><span class="line">    dispatch_apply(<span class="number">3</span>, dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^(size_t i) &#123; </span><br><span class="line"> </span><br><span class="line">        <span class="built_in">NSURL</span> *url; </span><br><span class="line">        <span class="keyword">switch</span> (i) &#123; </span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>: </span><br><span class="line">                url = [<span class="built_in">NSURL</span> URLWithString:kOverlyAttachedGirlfriendURLString]; </span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>: </span><br><span class="line">                url = [<span class="built_in">NSURL</span> URLWithString:kSuccessKidURLString]; </span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>: </span><br><span class="line">                url = [<span class="built_in">NSURL</span> URLWithString:kLotsOfFacesURLString]; </span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            <span class="keyword">default</span>: </span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">        &#125; </span><br><span class="line"> </span><br><span class="line">        dispatch_group_enter(downloadGroup); </span><br><span class="line">        Photo *photo = [[Photo alloc] initwithURL:url </span><br><span class="line">                              withCompletionBlock:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *_error) &#123; </span><br><span class="line">                                  <span class="keyword">if</span> (_error) &#123; </span><br><span class="line">                                      error = _error; </span><br><span class="line">                                  &#125; </span><br><span class="line">                                  dispatch_group_leave(downloadGroup); </span><br><span class="line">                              &#125;]; </span><br><span class="line"> </span><br><span class="line">        [[PhotoManager sharedManager] addPhoto:photo]; </span><br><span class="line">    &#125;); </span><br><span class="line"> </span><br><span class="line">    dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^&#123; </span><br><span class="line">        <span class="keyword">if</span> (completionBlock) &#123; </span><br><span class="line">            completionBlock(error); </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你的循环现在是并行运行的了；在上面的代码中，在调用 dispatch_apply 时，你用第一次参数指明了迭代的次数，用第二个参数指定了任务运行的队列，而第三个参数是一个 Block。</p>
<p>要知道虽然你有代码保证添加相片时线程安全，但图片的顺序却可能不同，这取决于线程完成的顺序。</p>
<p>编译并运行，然后从 “Le Internet” 添加一些照片。注意到区别了吗？</p>
<p>在真机上运行新代码会稍微更快的得到结果。但我们所做的这些提速工作真的值得吗？</p>
<p>实际上，在这个例子里并不值得。下面是原因：</p>
<ol>
<li><p>你创建并行运行线程而付出的开销，很可能比直接使用 for 循环要多。若你要以合适的步长迭代非常大的集合，那才应该考虑使用 dispatch_apply。</p>
</li>
<li><p>你用于创建应用的时间是有限的——除非实在太糟糕否则不要浪费时间去提前优化代码。如果你要优化什么，那去优化那些明显值得你付出时间的部分。你可以通过在 Instruments 里分析你的应用，找出最长运行时间的方法。看看 <a href="http://www.raywenderlich.com/23037/how-to-use-instruments-in-xcode" target="_blank" rel="external">如何在 Xcode 中使用 Instruments</a> 可以学到更多相关知识。</p>
</li>
<li><p>通常情况下，优化代码会让你的代码更加复杂，不利于你自己和其他开发者阅读。请确保添加的复杂性能换来足够多的好处。</p>
</li>
</ol>
<p>记住，不要在优化上太疯狂。你只会让你自己和后来者更难以读懂你的代码。</p>
<h3 id="GCD-的其他趣味"><a href="#GCD-的其他趣味" class="headerlink" title="GCD 的其他趣味"></a>GCD 的其他趣味</h3><p>等一下！还有更多！有一些额外的函数在不同的道路上走得更远。虽然你不会太频繁地使用这些工具，但在对的情况下，它们可以提供极大的帮助。</p>
<h4 id="阻塞——正确的方式"><a href="#阻塞——正确的方式" class="headerlink" title="阻塞——正确的方式"></a>阻塞——正确的方式</h4><p>这可能听起来像是个疯狂的想法，但你知道 Xcode 已有了测试功能吗？:] 我知道，虽然有时候我喜欢假装它不存在，但在代码里构建复杂关系时编写和运行测试非常重要。</p>
<p>Xcode 里的测试在 XCTestCase 的子类上执行，并运行任何方法签名以 test 开头的方法。测试在主线程运行，所以你可以假设所有测试都是串行发生的。</p>
<p>当一个给定的测试方法运行完成，XCTest 方法将考虑此测试已结束，并进入下一个测试。这意味着任何来自前一个测试的异步代码会在下一个测试运行时继续运行。</p>
<p>网络代码通常是异步的，因此你不能在执行网络获取时阻塞主线程。也就是说，整个测试会在测试方法完成之后结束，这会让对网络代码的测试变得很困难。也就是，除非你在测试方法内部阻塞主线程直到网络代码完成。</p>
<blockquote>
<p>注意：有一些人会说，这种类型的测试不属于集成测试的首选集（Preferred Set）。一些人会赞同，一些人不会。但如果你想做，那就去做。</p>
</blockquote>
<p>导航到 GooglyPuffTests.m 并查看 downloadImageURLWithString:，如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)downloadImageURLWithString:(<span class="built_in">NSString</span> *)URLString </span><br><span class="line">&#123; </span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:URLString]; </span><br><span class="line">    __block <span class="built_in">BOOL</span> isFinishedDownloading = <span class="literal">NO</span>; </span><br><span class="line">    __unused Photo *photo = [[Photo alloc] </span><br><span class="line">                             initwithURL:url </span><br><span class="line">                             withCompletionBlock:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error) &#123; </span><br><span class="line">                                 <span class="keyword">if</span> (error) &#123; </span><br><span class="line">                                     <span class="built_in">XCTFail</span>(<span class="string">@"%@ failed. %@"</span>, URLString, error); </span><br><span class="line">                                 &#125; </span><br><span class="line">                                 isFinishedDownloading = <span class="literal">YES</span>; </span><br><span class="line">                             &#125;]; </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (!isFinishedDownloading) &#123;&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是一种测试异步网络代码的幼稚方式。 While 循环在函数的最后一直等待，直到 isFinishedDownloading 布尔值变成 True，它只会在 Completion Block 里发生。让我们看看这样做有什么影响。</p>
<p>通过在 Xcode 中点击 Product / Test 运行你的测试，如果你使用默认的键绑定，也可以使用快捷键 ?+U 来运行你的测试。</p>
<p>在测试运行时，注意 Xcode debug 导航栏里的 CPU 使用率。这个设计不当的实现就是一个基本的 自旋锁 。它很不实用，因为你在 While 循环里浪费了珍贵的 CPU 周期；而且它也几乎没有扩展性。</p>
<blockquote>
<p>译者注：所谓自旋锁，就是某个线程一直抢占着 CPU 不断检查以等到它需要的情况出现。因为现代操作系统都是可以并发运行多个线程的，所以它所等待的那个线程也有机会被调度执行，这样它所需要的情况早晚会出现。</p>
</blockquote>
<p>你可能需要使用前面提到的 Network Link Conditioner ，已便清楚地看到这个问题。如果你的网络太快，那么自旋只会在很短的时间里发生，难以观察。</p>
<p>你需要一个更优雅、可扩展的解决方案来阻塞线程直到资源可用。欢迎来到信号量。</p>
<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>信号量是一种老式的线程概念，由非常谦卑的 Edsger W. Dijkstra 介绍给世界。信号量之所以比较复杂是因为它建立在操作系统的复杂性之上。</p>
<p>如果你想学到更多关于信号量的知识，看看<a href="http://greenteapress.com/semaphores/" target="_blank" rel="external">这个链接</a>它更细致地讨论了信号量理论。如果你是学术型，那可以看一个软件开发中经典的<a href="http://greenteapress.com/semaphores/" target="_blank" rel="external">哲学家进餐问题</a>，它需要使用信号量来解决。</p>
<p>信号量让你控制多个消费者对有限数量资源的访问。举例来说，如果你创建了一个有着两个资源的信号量，那同时最多只能有两个线程可以访问临界区。其他想使用资源的线程必须在一个…你猜到了吗？…FIFO队列里等待。</p>
<p>让我们来使用信号量吧！</p>
<p>打开 GooglyPuffTests.m 并用下列实现替换 downloadImageURLWithString:</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)downloadImageURLWithString:(<span class="built_in">NSString</span> *)URLString</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    dispatch_semaphore_t semaphore = dispatch_semaphore_create(<span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">NSURL</span> *url = [<span class="built_in">NSURL</span> URLWithString:URLString];</span><br><span class="line">    __unused Photo *photo = [[Photo alloc]</span><br><span class="line">                             initwithURL:url</span><br><span class="line">                             withCompletionBlock:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSError</span> *error) &#123;</span><br><span class="line">                                 <span class="keyword">if</span> (error) &#123;</span><br><span class="line">                                     <span class="built_in">XCTFail</span>(<span class="string">@"%@ failed. %@"</span>, URLString, error);</span><br><span class="line">                                 &#125;</span><br><span class="line"> </span><br><span class="line">                                 <span class="comment">// 2</span></span><br><span class="line">                                 dispatch_semaphore_signal(semaphore);</span><br><span class="line">                             &#125;];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    dispatch_time_t timeoutTime = dispatch_time(DISPATCH_TIME_NOW, kDefaultTimeoutLengthInNanoSeconds);</span><br><span class="line">    <span class="keyword">if</span> (dispatch_semaphore_wait(semaphore, timeoutTime)) &#123;</span><br><span class="line">        <span class="built_in">XCTFail</span>(<span class="string">@"%@ timed out"</span>, URLString);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面来说明你代码中的信号量是如何工作的：</p>
<ol>
<li><p>创建一个信号量。参数指定信号量的起始值。这个数字是你可以访问的信号量，不需要有人先去增加它的数量。（注意到增加信号量也被叫做发射信号量）。译者注：这里初始化为0，也就是说，有人想使用信号量必然会被阻塞，直到有人增加信号量。</p>
</li>
<li><p>在 Completion Block 里你告诉信号量你不再需要资源了。这就会增加信号量的计数并告知其他想使用此资源的线程。</p>
</li>
<li><p>这会在超时之前等待信号量。这个调用阻塞了当前线程直到信号量被发射。这个函数的一个非零返回值表示到达超时了。在这个例子里，测试将会失败因为它以为网络请求不会超过 10 秒钟就会返回——一个平衡点！</p>
</li>
</ol>
<p>再次运行测试。只要你有一个正常工作的网络连接，这个测试就会马上成功。请特别注意 CPU 的使用率，与之前使用自旋锁的实现作个对比。</p>
<p>关闭你的网络链接再运行测试；如果你在真机上运行，就打开飞行模式。如果你的在模拟器里运行，你可以直接断开 Mac 的网络链接。测试会在 10 秒后失败。这很棒，它真的能按照预想的那样工作！</p>
<p>还有一些琐碎的测试，但如果你与一个服务器组协同工作，那么这些基本的测试能够防止其他人就最新的网络问题对你说三道四。</p>
<h4 id="使用-Dispatch-Source"><a href="#使用-Dispatch-Source" class="headerlink" title="使用 Dispatch Source"></a>使用 Dispatch Source</h4><p>GCD 的一个特别有趣的特性是 Dispatch Source，它基本上就是一个低级函数的 grab-bag ，能帮助你去响应或监测 Unix 信号、文件描述符、Mach 端口、VFS 节点，以及其它晦涩的东西。所有这些都超出了本教程讨论的范围，但你可以通过实现一个 Dispatch Source 对象并以一个相当奇特的方式来使用它来品尝那些晦涩的东西。</p>
<p>第一次使用 Dispatch Source 可能会迷失在如何使用一个源，所以你需要知晓的第一件事是 dispatch_source_create 如何工作。下面是创建一个源的函数原型：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">dispatch_source_t dispatch_source_create(</span><br><span class="line">   dispatch_source_type_t type,</span><br><span class="line">   uintptr_t handle,</span><br><span class="line">   <span class="keyword">unsigned</span> <span class="keyword">long</span> mask,</span><br><span class="line">   <span class="built_in">dispatch_queue_t</span> queue);</span><br></pre></td></tr></table></figure>
<p>第一个参数是 dispatch_source_type_t 。这是最重要的参数，因为它决定了 handle 和 mask 参数将会是什么。你可以查看 <a href="https://developer.apple.com/library/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html#//apple_ref/doc/constant_group/Dispatch_Source_Type_Constants" target="_blank" rel="external">Xcode 文档</a> 得到哪些选项可用于每个 dispatch_source_type_t 参数。</p>
<p>下面你将监控 DISPATCH_SOURCE_TYPE_SIGNAL 。如<a href="https://developer.apple.com/library/mac/documentation/Performance/Reference/GCD_libdispatch_Ref/Reference/reference.html#//apple_ref/c/macro/DISPATCH_SOURCE_TYPE_SIGNAL%22" target="_blank" rel="external">文档所显示的</a>：</p>
<p>一个监控当前进程信号的 Dispatch Source。 handle 是信号编号，mask 未使用（传 0 即可）。</p>
<p>这些 Unix 信号组成的列表可在头文件 <a href="http://www.opensource.apple.com/source/xnu/xnu-1456.1.26/bsd/sys/signal.h" target="_blank" rel="external">signal.h</a> 中找到。在其顶部有一堆 #define 语句。你将监控此信号列表中的 SIGSTOP 信号。这个信号将会在进程接收到一个无法回避的暂停指令时被发出。在你用 LLDB 调试器调试应用时你使用的也是这个信号。</p>
<p>去往 PhotoCollectionViewController.m 并添加如下代码到 viewDidLoad 的顶部，就在 [super viewDidLoad] 下面：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)viewDidLoad</span><br><span class="line">&#123;</span><br><span class="line">  [<span class="keyword">super</span> viewDidLoad];</span><br><span class="line"> </span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="meta">#if DEBUG</span></span><br><span class="line">      <span class="comment">// 2</span></span><br><span class="line">      <span class="built_in">dispatch_queue_t</span> queue = dispatch_get_main_queue();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 3</span></span><br><span class="line">      <span class="keyword">static</span> dispatch_source_t source = <span class="literal">nil</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 4</span></span><br><span class="line">      __<span class="keyword">typeof</span>(<span class="keyword">self</span>) __<span class="keyword">weak</span> weakSelf = <span class="keyword">self</span>;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">// 5</span></span><br><span class="line">      <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</span><br><span class="line">      <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">          <span class="comment">// 6</span></span><br><span class="line">          source = dispatch_source_create(DISPATCH_SOURCE_TYPE_SIGNAL, SIGSTOP, <span class="number">0</span>, queue);</span><br><span class="line"> </span><br><span class="line">          <span class="comment">// 7</span></span><br><span class="line">          <span class="keyword">if</span> (source)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="comment">// 8</span></span><br><span class="line">              dispatch_source_set_event_handler(source, ^&#123;</span><br><span class="line">                  <span class="comment">// 9</span></span><br><span class="line">                  <span class="built_in">NSLog</span>(<span class="string">@"Hi, I am: %@"</span>, weakSelf);</span><br><span class="line">              &#125;);</span><br><span class="line">              dispatch_resume(source); <span class="comment">// 10</span></span><br><span class="line">          &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">  <span class="meta">#endif</span></span><br><span class="line"> </span><br><span class="line">  <span class="comment">// The other stuff</span></span><br></pre></td></tr></table></figure>
<p>这些代码有点儿复杂，所以跟着注释一步步走，看看到底发生了什么：</p>
<ol>
<li><p>最好是在 DEBUG 模式下编译这些代码，因为这会给“有关方面（Interested Parties）”很多关于你应用的洞察。</p>
</li>
<li><p>Just to mix things up，你创建了一个 dispatch_queue_t 实例变量而不是在参数上直接使用函数。当代码变长，分拆有助于可读性。</p>
</li>
<li><p>你需要 source 在方法范围之外也可被访问，所以你使用了一个 static 变量。</p>
</li>
<li><p>使用 weakSelf 以确保不会出现保留环（Retain Cycle）。这对 PhotoCollectionViewController 来说不是完全必要的，因为它会在应用的整个生命期里保持活跃。然而，如果你有任何其它会消失的类，这就能确保不会出现保留环而造成内存泄漏。</p>
</li>
<li><p>使用 dispatch_once 确保只会执行一次 Dispatch Source 的设置。</p>
</li>
<li><p>初始化 source 变量。你指明了你对信号监控感兴趣并提供了 SIGSTOP 信号作为第二个参数。进一步，你使用主队列处理接收到的事件——很快你就好发现为何要这样做。</p>
</li>
<li><p>如果你提供的参数不合格，那么 Dispatch Source 对象不会被创建。也就是说，在你开始在其上工作之前，你需要确保已有了一个有效的 Dispatch Source 。</p>
</li>
<li><p>当你收到你所监控的信号时，dispatch_source_set_event_handler 就会执行。之后你可以在其 Block 里设置合适的逻辑处理器（Logic Handler）。</p>
</li>
<li><p>一个基本的 NSLog 语句，它将对象打印到控制台。</p>
</li>
<li><p>默认的，所有源都初始为暂停状态。如果你要开始监控事件，你必须告诉源对象恢复活跃状态。</p>
</li>
</ol>
<p>编译并运行应用；在调试器里暂停并立即恢复应用，查看控制台，你会看到这个来自黑暗艺术的函数确实可以工作。你看到的大概如下：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line"><span class="number">2014</span><span class="number">-03</span><span class="number">-29</span> <span class="number">17</span>:<span class="number">41</span>:<span class="number">30.610</span> GooglyPuff[<span class="number">8181</span>:<span class="number">60</span>b] Hi, I am:</span><br></pre></td></tr></table></figure>
<p>你的应用现在具有调试感知了！这真是超级棒，但在真实世界里该如何使用它呢？</p>
<p>你可以用它去调试一个对象并在任何你想恢复应用的时候显示数据；你同样能给你的应用加上自定义的安全逻辑以便在恶意攻击者将一个调试器连接到你的应用上时保护它自己（或用户的数据）。</p>
<p>一个有趣的主意是，使用此方式的作为一个堆栈追踪工具去找到你想在调试器里操纵的对象。 </p>
<p>稍微想想这个情况。当你意外地停止调试器，你几乎从来都不会在所需的栈帧上。现在你可以在任何时候停止调试器并在你所需的地方执行代码。如果你想在你的应用的某一点执行的代码非常难以从调试器访问的话，这会非常有用。有机会试试吧！ </p>
<p>将一个断点放在你刚添加在 viewDidLoad 里的事件处理器的 NSLog 语句上。在调试器里暂停，然后再次开始；应用会到达你添加的断点。现在你深入到你的 PhotoCollectionViewController 方法深处。你可以访问 PhotoCollectionViewController 的实例得到你关心的内容。非常方便！</p>
<blockquote>
<p>注意：如果你还没有注意到在调试器里的是哪个线程，那现在就看看它们。主线程总是第一个被 libdispatch 跟随，它是 GCD 的坐标，作为第二个线程。之后，线程计数和剩余线程取决于硬件在应用到达断点时正在做的事情。</p>
</blockquote>
<p>在调试器里，键入命令：</p>
<figure class="highlight objectivec"><table><tr><td class="code"><pre><span class="line">po [[weakSelf navigationItem] setPrompt:<span class="string">@"WOOT!"</span>]</span><br></pre></td></tr></table></figure>
<p>然后恢复应用的执行。你会看到如下内容：</p>
<p><img src="https://cdn5.raywenderlich.com/wp-content/uploads/2014/01/Dispatch_Sources_Xcode_Breakpoint_Console-650x500.png" alt=""></p>
<p><img src="https://cdn1.raywenderlich.com/wp-content/uploads/2014/01/Dispatch_Sources_Debugger_Updating_UI-308x500.png" alt=""></p>
<p>使用这个方法，你可以更新 UI、查询类的属性，甚至是执行方法——所有这一切都不需要重启应用并到达某个特定的工作状态。相当优美吧！</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>你可以在此<a href="http://www.raywenderlich.com/wp-content/uploads/2014/01/GooglyPuff-Final.zip" target="_blank" rel="external">下载最终的项目</a>。</p>
<p>我讨厌再次提及此主题，但你真的要看看 <a href="https://www.raywenderlich.com/?p=23037" target="_blank" rel="external">如何使用 Instruments</a> 教程。如果你计划优化你的应用，那你一定要学会使用它。请注意 Instruments 擅长于分析相对执行：比较哪些区域的代码相对于其它区域的代码花费了更长的时间。如果你尝试计算出某个方法实际的执行时间，那你可能需要拿出更多的自酿的解决方案（Home-brewed Solution）。</p>
<p>同样请看看 <a href="http://www.raywenderlich.com/19788/how-to-use-nsoperations-and-nsoperationqueues" target="_blank" rel="external">如何使用 NSOperations 和 NSOperationQueues</a> 吧，它们是建立在 GCD 之上的并发技术。大体来说，如果你在写简单的用过就忘的任务，那它们就是使用 GCD 的最佳实践，。NSOperations 提供更好的控制、处理大量并发操作的实现，以及一个以速度为代价的更加面向对象的范例。</p>
<p>记住，除非你有特别的原因要往下流走（译者的玩笑：即使用低级别 API），否则永远应尝试并坚持使用高级的 API。如果你想学到更多或想做某些非常非常“有趣”的事情，那你就应该冒险进入 Apple 的黑暗艺术。</p>
<blockquote>
<p>Reference<br><a href="https://www.raywenderlich.com/60749/grand-central-dispatch-in-depth-part-1" target="_blank" rel="external">Grand Central Dispatch In-Depth: Part 1/2</a> <a href="http://www.cocoachina.com/industry/20140428/8248.html" target="_blank" rel="external">中文</a><br><a href="https://www.raywenderlich.com/63338/grand-central-dispatch-in-depth-part-2" target="_blank" rel="external">Grand Central Dispatch In-Depth: Part 2/2</a> <a href="http://www.cocoachina.com/ios/20140515/8433.html" target="_blank" rel="external">中文</a></p>
</blockquote>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="https://github.com/wossoneri/wossoneri.github.io/blob/master/pay/wechatpay.JPG?raw=true" alt="Wossoneri 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="https://github.com/wossoneri/wossoneri.github.io/blob/master/pay/alipay.JPG?raw=true" alt="Wossoneri 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Wossoneri
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://wossoneri.github.io/2016/05/30/[Objective-C]GCD-in-depth/" title="[Objective-C]深入理解GCD">http://wossoneri.github.io/2016/05/30/[Objective-C]GCD-in-depth/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/iOS/" rel="tag"><i class="fa fa-tag"></i> iOS</a>
          
            <a href="/tags/Objective-C/" rel="tag"><i class="fa fa-tag"></i> Objective-C</a>
          
            <a href="/tags/GCD/" rel="tag"><i class="fa fa-tag"></i> GCD</a>
          
            <a href="/tags/多线程/" rel="tag"><i class="fa fa-tag"></i> 多线程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/05/30/[Objective-C]Multithreading-and-GCD/" rel="next" title="[Objective-C]多线程和GCD">
                <i class="fa fa-chevron-left"></i> [Objective-C]多线程和GCD
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/06/04/[Objective-C]Copy-and-MutableCopy/" rel="prev" title="[Objective-C] Copy 和 MutableCopy">
                [Objective-C] Copy 和 MutableCopy <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="https://avatars2.githubusercontent.com/u/11764431?v=3&s=460"
                alt="Wossoneri" />
            
              <p class="site-author-name" itemprop="name">Wossoneri</p>
              <p class="site-description motion-element" itemprop="description">就怕你一生碌碌无为，还安慰自己平凡可贵</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">42</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">59</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          <div class="links-of-author motion-element">
            
              
                <span class="links-of-author-item">
                  <a href="https://github.com/wossoneri" target="_blank" title="GitHub">
                    
                      <i class="fa fa-fw fa-globe"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  <a href="http://weibo.com/u/1171637315/home?topnav=1&wvr=5" target="_blank" title="Weibo">
                    
                      <i class="fa fa-fw fa-globe"></i>Weibo</a>
                </span>
              
            
          </div>

          
          
            <div class="cc-license motion-element" itemprop="license">
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
                <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
              </a>
            </div>
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-globe"></i>
                友情链接
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.cnblogs.com/rossoneri/" title="我的博客园博客" target="_blank">我的博客园博客</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="http://zhangqinglian.github.io/" title="清廉的Android博客" target="_blank">清廉的Android博客</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#什么是GCD"><span class="nav-number">1.</span> <span class="nav-text">什么是GCD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GCD术语"><span class="nav-number">2.</span> <span class="nav-text">GCD术语</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Serial串行-vs-Concurrent并发"><span class="nav-number">2.1.</span> <span class="nav-text">Serial串行 vs. Concurrent并发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Synchronous同步-vs-Asynchronous异步"><span class="nav-number">2.2.</span> <span class="nav-text">Synchronous同步 vs. Asynchronous异步</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Critical-Section-临界区"><span class="nav-number">2.3.</span> <span class="nav-text">Critical Section 临界区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Race-Condition-竞态条件"><span class="nav-number">2.4.</span> <span class="nav-text">Race Condition 竞态条件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Deadlock-死锁"><span class="nav-number">2.5.</span> <span class="nav-text">Deadlock 死锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Thread-Safe-线程安全"><span class="nav-number">2.6.</span> <span class="nav-text">Thread Safe 线程安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Context-Switch-上下文切换"><span class="nav-number">2.7.</span> <span class="nav-text">Context Switch 上下文切换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Concurrency并发-vs-Parallelism并行"><span class="nav-number">2.8.</span> <span class="nav-text">Concurrency并发 vs Parallelism并行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Queues-队列"><span class="nav-number">2.9.</span> <span class="nav-text">Queues 队列</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Serial-Queues-串行队列"><span class="nav-number">2.9.1.</span> <span class="nav-text">Serial Queues 串行队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Concurrent-Queues-并发队列"><span class="nav-number">2.9.2.</span> <span class="nav-text">Concurrent Queues 并发队列</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Queue-Types-队列类型"><span class="nav-number">2.10.</span> <span class="nav-text">Queue Types 队列类型</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开始使用"><span class="nav-number">3.</span> <span class="nav-text">开始使用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用-dispatch-async-处理后台任务"><span class="nav-number">4.</span> <span class="nav-text">用 dispatch_async 处理后台任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#使用-dispatch-after-延后工作"><span class="nav-number">5.</span> <span class="nav-text">使用 dispatch_after 延后工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#让你的单例线程安全"><span class="nav-number">6.</span> <span class="nav-text">让你的单例线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#处理读者与写者问题"><span class="nav-number">7.</span> <span class="nav-text">处理读者与写者问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#A-Visual-Review-of-Queueing-队列的虚拟回顾"><span class="nav-number">8.</span> <span class="nav-text">A Visual Review of Queueing 队列的虚拟回顾</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#dispatch-sync-回顾"><span class="nav-number">8.1.</span> <span class="nav-text">dispatch_sync 回顾</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#dispatch-async-回顾"><span class="nav-number">8.2.</span> <span class="nav-text">dispatch_async 回顾</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#准备下一步"><span class="nav-number">9.</span> <span class="nav-text">准备下一步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#纠正过早弹出的提示"><span class="nav-number">10.</span> <span class="nav-text">纠正过早弹出的提示</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dispatch-Groups（调度组）"><span class="nav-number">11.</span> <span class="nav-text">Dispatch Groups（调度组）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dispatch-Group，第二种方式"><span class="nav-number">12.</span> <span class="nav-text">Dispatch Group，第二种方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#太多并发带来的风险"><span class="nav-number">13.</span> <span class="nav-text">太多并发带来的风险</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#GCD-的其他趣味"><span class="nav-number">14.</span> <span class="nav-text">GCD 的其他趣味</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#阻塞——正确的方式"><span class="nav-number">14.1.</span> <span class="nav-text">阻塞——正确的方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#信号量"><span class="nav-number">14.2.</span> <span class="nav-text">信号量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用-Dispatch-Source"><span class="nav-number">14.3.</span> <span class="nav-text">使用 Dispatch Source</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#最后"><span class="nav-number">15.</span> <span class="nav-text">最后</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Wossoneri</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("RHlsmdBRQUmQMHNOl3U1ocam-gzGzoHsz", "RU2vFPiDzi68XGHCgJXtBAqo");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/love.js"></script>
